- must handle persistent, detached, read-only and in-memory cases
- The act of serializing a persistent object is equivalent to detach, then serialize
	- the effect of this is make the objects coming back to be in a detached state
- detached objects should come back as detached
- in-memory objects should come back as in-memory
- read-only objects are either persisted, or in-memory
	- deserialization of persisted read-only objects retrieves the unique instance.
		- try to IO optimize this on a list deserialization
- two choices for navigation following:
	- navigation based, rooted at one point. just like reladomo deep fetches
		- a little harder to reuse/abstract out, but quite possible if the code is just like deep fetch.
	- No: class based. with max depth.
		- for each config, each class specifies what to navigate.
		- while this is interesting, it's not consistent with the existing deepFetch semantics
			- supporting this could mean supporting a different kind of deepFetch
				- only seems interesting for navigations that have loops

- annotations:
	- used for methods declared on the concrete classes
	- only support parameterless methods
	- @ReladomoSerialize(Class[]) where Class[] is a set of view classes (really, marker classes, used for type safe naming)

- generic serializer:
	- usually a framework, like gson, will call something like:
			serialize(reladomoObject, serializationContext)
		on a registered implementation of the serializer
	- to delegate, let's wrap serializationContext into a ReladomoSerializationContext
	- must register serializers for both reladomo objects and lists
	- exception handling: writer throws IOException
	
	ReladomoSerializationContext:
		- serialize(reladomoObject)
		- serialize(reladomoObject, List<Navigation)
		- is given a list of navigations to follow
			- this will come from the deep fetches on a list automatically
		- can exclude attributes
		- can use a named configuration
		- outputs links for the rest of the navigations
		- delegates to a writer:
			- always passes in the original object
			- writeStart(reladomoObject)
			- writeInt(reladomoObject, name, value), writeLong, ...
			- writeNull(reladomoObject, name)
			- writeList
			- writeLink(reladomoObject, linkName, linkAttributes, linkParams)
			- writeObject(reladomoObject, attrName, objectToWrite)
			- writeEnd(reladomoObject)
			- names starting with _rdo are reladomo internal
				- _rdoState: 1 (in-memory), 4 (detached), 100 (read-only)
				- _rdoClass: java class name
- done: Serialized<T Extends MithraObject> and SerialziedList<T extends MithraList>
	- universal wrappers that can be registered with serialization framworks (gson/jackson/etc)
- deal with parameterized relationships
	- no good way to do this in json. The best is probably a nested structure:
	
	{
		"productId": 7,
		synonymByType: {
			"cusip": {
				"type": "cusip",
				"value": "XYZ"
			},
			"isn": {
				"type": "isn",
				"value": "XYZ"
			}
		}
	}
	- requires navigating all of parameters together
	- further nesting will result if the method has multiple params
		- for json, serialization must be sorted in parameter repetition. e.g. method.p1a.p2a, then method.p1a.p2b, then method.p1c.p2a, etc.
	- if the parameter value is complex (e.g. a set), it all falls apart
- circular references: json can't really handle it without a custom de/serializer.
	- beyond the scope of the main serializer. There is enough info passed around to be implementable by a context/writer impl
- xml example:
